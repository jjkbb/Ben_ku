整个程序分为三部分:bootloader,localname,程序主体.

bootloader:读取名字     
localname:各个传感版通过它来区分进入主程序的哪个任务.------benebot5: lidar,bodycontrol,headcontrol,uarttocan,超声波ultasonic.
程序主体:读取名字--->初始化--->进入具体任务.

看门狗:软件窗口看门狗,每运行一次主循环都会喂一下,超时复位.
       !!!软件每次喂狗之前必须关闭所有中断(全局中断),喂完再打开.喂狗很快的,不用担心程序会卡住或是担心此时响应中断.若是不这么做,会有几率喂狗的时候响应中断,会互相冲突,导致复位.实测几小时会自动复位一下,就是这个原因.

IIC:有现成的函数可调用(主写:i2c_master_write,主读:i2c_master_read),入口参数分别为:主设备地址,从设备地址,从设备寄存器地址,要写的数据的地址/读到的数据要存放的地址,数据长度(单位为字节).
    !!!用ke06读sharp的 time of flight(TOF)激光测距传感器时(IIC读取方式,也可以串口,但是没试过),读测量的数据前,要先把手册上告诉我们的可配置寄存器都配置一遍.

灯效:有两块板子可以控制灯效:lidar和bodycontrol.
     灯带12v供电,是常开的,驱动芯片5v供电,是可控的.12v开,5v关时,灯带程淡绿色,因为此时灯带不受控制,还有电.不要尝试想什么数据状态不动他,等就会维持上一次的状态.有5v时是这样子的,因为驱动芯片在工作着.
     灯的状态,具体应该怎么亮,是根据从can网获取的机器状态来判断的.电池分充电,不充电,充满电.机器有开机,关机.此外,还有急停状态,故障状态(这个目前还没有用到,只是把状态写着).机器触发关机时,会有一个标志状态位0--->1(shutdown),这个是用来表示给x86下发关机命令的.有个开关机状态标志位(close_or_open),下面1020每隔一秒更新一次其数值.触发关机后,要求电源30秒后再断电.
     刚刚开机时,灯会短暂地亮一下白光,之后会变为正常的蓝色(开机不充电).为什么捏?因为机器刚刚上电时,电来了,灯来电了(此时控制灯的mcu来电处于初始状态,灯有电,驱动芯片有电).但是!下面的mcu还没把相关信息读取好并发给控制灯的mcu,所以,等就是白色的,驱动芯片在没收到控制数据信号时,rgb都是最大值,就是白光.要想解决这个问题,就得改硬件,让灯的12v可控.
     以上是两块板子灯效共有的问题,下面是各自的问题记录.
     lidar:因为刚刚开机时1020还来不及把电池和机器的状态信号传递上来(或是刚刚上电,电池内置的芯片还没来得及把数据处理好让1020读),有那么短暂的一会会从can网上读取的信息是关机不充电的,灯带会先白下下(为啥会亮白光上面有讲),然后灭一下下,之后又重新亮(这时候才正常亮).为了解决这个问题,我直接在开机时,让程序延时了一会,然后再正常进入任务.这样做会导致开机时灯带会长亮(蓝灯)一会,时间根据延时函数决定.
     bodycontrol:最搞的地方来了.按照要求,关机触发后分两种情况:正常关机和充着电关机.正常关机触发后的那30秒,灯灭电源不断;充电关机触发后(这之前是蓝色呼吸灯),得先让灯短暂地灭一会儿,然后接着呼吸,因为关机充电和开机充电都是蓝色呼吸灯.为了区分按下关机按钮后机器是真的要关机还是在充电,就有了上面这俩要求.个人觉得我写的那个方法还是挺妙的,要是现在的benben忘了当初有多机智,劝你再去搂几眼,2020.6.6的benben就不多说了(就是那个if(shutdown)判断语句那一块,用到中断的).
